## IO模型

### 同步和异步

- 同步是指用户线程发起IO请求后需要等待，或者轮训内核I/O操作完成后才能继续执行
- 异步是指用户线程发起I/O请求后仍继续执行，当内核I/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数。

### 阻塞和非阻塞

- 阻塞是指I/O操作需要彻底完成后才能返回用户空间；
- 非阻塞是指I/O操作被调用后立即返回给用户一个状态值，无须等到I/O操作彻底完成

> 阻塞I/O和非阻塞I/O的区别在于第一步，也就是发起I/O请求是否会被阻塞。如果阻塞直到完成，就是传统的阻塞I/O，如果不阻塞，就是非阻塞I/O。
>
> 同步I/O和异步I/O的区别在于第二步是否阻塞，如果实际的I/O读写阻塞请求进程，就是同步I/O。

### UNIX I/O模型

> 阻塞I/O、非阻塞I/O、I/O复用（select和poll）、信号驱动I/O（SIGIO）、异步I/O（Posix.1的aio_系列函数）



#### 阻塞I/O模型

> 请求无法立即完成则保持阻塞。

- 阶段1:等待数据就绪。网络I/O的请求就是等待远端数据陆续抵达，磁盘I/O的请求就是等待磁盘数据从磁盘上读取到内核态内存中。
- 阶段2:数据复制。出于系统安全考虑，用户态的程序没有权限直接读取内核态内存，因此内核负责把内核态内存中的数据复制一份到用户态内存中。

#### 非阻塞I/O模型

- 阶段1:socket设置为非阻塞（NONBLOCK），当所有请求的I/O操作无法完成时，不要让进程进入睡眠状态，而是立即返回一个错误码，这样请求就不会阻塞
- 阶段2:I/O操作函数将不断地测试数据是否已经准备好，如果没有准备好，则继续测试，直到数据准备好为止。在整个I/O请求的过程中，虽然用户线程每次发起I/O请求后可以立即返回，但是为了等到数据，仍需轮询、重复请求，而这是对CPU时间的极大浪费。
- 阶段3:数据准备好了，从内核复制到用户空间。

#### I/O复用模型

