## 持久化

> Redis持久化提供了两种方式：AOF（appendonly file）和RDB（Redis DB）

| 命令       | AOF                                | RDB          |
| ---------- | ---------------------------------- | ------------ |
| 启动优先级 | 低                                 | 高           |
| 体积       | 小                                 | 大           |
| 恢复速度   | 快                                 | 慢           |
| 数据安全性 | 容易丢数据<br />（最多丢一秒数据） | 根据策略决定 |

### RDB

> 保存的是某一时刻的全量数据  
>
> 会丢数据

save与bgsave对比

| 命令                    | save             | bgsave                                           |
| ----------------------- | ---------------- | ------------------------------------------------ |
| IO类型                  | 同步             | 异步                                             |
| 是否会阻塞redis其他命令 | 是               | 否（在生成子进程执行调用fork函数时会有短暂阻塞） |
| 复杂度                  | O(n)             | O(n)                                             |
| 优点                    | 不会额外消耗内存 | 不会阻塞客户端命令                               |
| 缺点                    | 阻塞客户端命令   | 需要fork子进程，消耗内存                         |

### AOF

> 将修改的每一条命令记录到文件appendonly.aof中（先写os cache，每隔一段时间fsync到磁盘）

- AOF重写

  > AOF文件里可能有太多没用的指令，所以AOF会定期根据内存的最新数据生成AOF文件  
  >
  > 控制重写频率auto-aof-rewrite-min-size、auto-aof-rewrite-percentage

### Redis4.0 混合持久化

> 开启之后，AOF重写时，不再单纯将内存数据转换为RESP命令写入AOF文件，而是将重写那一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量AOF修改内存数据的命令存在一起，都写入新的AOF文件，新的文件已开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。于是在Redis重启的时候，可以先加载RDB的内容，再重放增量AOF日志就可以完全替代之前的AOF全量文件重放，因此重启效率大幅得到提升。