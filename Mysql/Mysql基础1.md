## WAL

> 先更新内存 ->  记录日志文件（redo log） -> 等待空闲时间写入磁盘

- 当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。

### 刷脏页

刷脏页的四个场景：

- redo log写满了，这种情况是Innodb要尽量避免的
    - redo log写满了，要flush脏页，这个时候整个系统就不能再接受更新了，所有的更新都必须停止。
- 内存不够用了，要先将脏页写到磁盘，这种是常态
    - 一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长
    - 日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的
    - InnoDB 需要有控制脏页比例的机制，来尽量避免上面的这两种情况。
- Mysql认为系统空闲的时候（为了提高效率）
- Mysql正常关闭的时候,Mysql会把内存的脏页都flush到磁盘。这样下次Mysql启动的时候就可以直接从磁盘上读数据，启动速度很快。

一种刷脏页的行为的另一种更慢的原因：刷脏页时，发现这个数据页旁边的数据页也是脏页就会把这个脏页也一起刷掉。<br>
innodb_flush_neighbors 参数就是用来控制这个行为的，值为 1 的时候会有上述的“连坐”机制，值为 0时表示不找邻居，自己刷自己的。<br>
在 MySQL 8.0 中，innodb_flush_neighbors 参数的默认值已经是 0 了。

## 空间回收

- 数据删除流程
    - 删除数据，Innodb引擎只有把数据标记为删除，再次插入的时候可能会复用这个位置，
    - 但是数据页的复用跟记录的复用是不同的，记录的复用，只限于符合范围条件的数据。
    - delete命令其实只是把记录的位置或数据页标记为可复用.

- 空洞

#### 造成空洞的原因

- 删除记录
    - 被标记为可复用的空间没有被复用
- 插入数据
    - 如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。
- 更新索引值
    - 可以理解为删除一个旧的值，再插入一个新值

## 重建表

命令

```mysql
 alter table A
  engine =InnoDB
```

## count(*) 的实现方式

- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高
- InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

- count(主键id)
    - InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。
- count(1)
    - InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。
- count(字段)
    - 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
    - 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。
- count(*)
    - 并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。

按照效率排序的话，count(字段)<count(主键id)<count(1)≈count(*)