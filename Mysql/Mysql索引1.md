## 优化器的逻辑

> 优化器优化时会考虑的因素： 1.扫描行数 2.是否使用临时表 3. 是否需要排序

- 扫描行数是怎么判断的
    - MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。
    - 这个统计信息就是索引的“区分度”

- MySQL 是怎样得到索引的基数的呢
  - 采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。
  - 而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。
  - 在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent 的值来选择：
  - 设置为 on 的时候，表示统计信息会持久化存储。
  - 设置为 off 的时候，表示统计信息只存储在内存中。

- 统计信息不对
  > analyze table t 命令，可以用来重新统计索引信息

- 索引选择异常和处理
  - 一种方法是，像我们第一个例子一样，采用 force index 强行选择一个索引。
  - 第二种方法就是，我们可以考虑修改语句，引导 MySQL 使用我们期望的索引。
  - 第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。